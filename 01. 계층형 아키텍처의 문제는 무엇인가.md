<img src="https://user-images.githubusercontent.com/20153890/152680330-c108574b-578a-4a06-9332-b435d5fc5cc5.png" width=300>

> 1.1 웹 계층, 도메인 계층, 영속성 계층으로 구성된 전통적인 웹 어플리케이션 구조 

일반적인 3계층 아키텍처를 표현한 그림이다. 
- 요청 > 웹 서비스 계층 > 도메인 혹은 비즈니스 계층 서비스 (서비스는 비즈니스 로직 수행) > 영속성 계층 컴포넌트 

잘 만들어진 계층형 아키텍처는 좋다
- 계층을 잘 이해하고 구성하면 웹 계층이나 영속성 계층에 독립적으로 도메인 로직 작성 가능 
- 원한다면 도메인 로직은 그대로 두고 웹 계층이나 영속성 계층의 기술을 변경할 수 있음

**즉 선택의 폭을 넓히고, 변화에 강하다.** 

그렇다면 문제점은? 

<br>

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다. 
- 웹 계층은 도메인 계층에 의존
- 도메인은 영속성 계층에 의존 

결국 자연스레 데이터베이스에 의존하게 됨, 즉 모든 것이 `영속성 계층`을 토대로 만들어진다.

일반적으로 도메인 로직을 먼저 구현했는가? 영속성 계층을 먼저 구현했는가 
- 대부분 데이터베이스 구조를 먼저 생각하고, 이를 토대로 도메인 로직을 구현 

의존성 방향에 따라 자연스럽게 구현한 것이기에, 이는 전통적인 계층형 아키텍처에서는 합리적이다.

하지만 비즈니스 관점에서는 전혀 아님 
- 무엇보다도 도메인 로직을 먼저 만들어야한다. 
- 도메인 로직이 맞다는 것을 확인한 후에 이를 기반으로 영속성 계층과 웹 계층을 만들어야한다. 

DB 중심적 아키텍처가 만들어지는 가장 큰 원인은 ORM 프레임워크 > 비즈니스 규칙을 영속성 관점에서 섞고 싶은 유혹


<img src="https://user-images.githubusercontent.com/20153890/152680618-cb5fd1f0-89e2-4e09-87e3-f1677999d275.png" width=300>

> 도메인 계층에서 데이터베이스 엔티티를 사용하는 것은 영속성 계층과의 강한 결합을 유발한다. 


그림처럼 ORM에 의해 관리되는 엔티티들은 영속성 계층에 속하나, 도메인 레이어에서 접근 가능하기에 결국 사용된다. 

**이렇게 되면 영속성/도메인 계층간의 강결합 생긴다.** 
- 서비스는 영속성 모델을 비즈니스 모델처럼 사용하게 된다. 
- 이로인해 서비스는 도메인 로직뿐 아니라 lazy loading, 트랜잭션, 캐시 flush 등 영속성 계층과 관련된 작업을 해야한다. 

영속성 엔티티가 도메인 코드에 들어가다보면, 둘 중 하나만 바꾸는게 어려워짐 > 유연하게 대처할 수 없어짐

> 도메인 엔티티와 영속성 계층의 엔티티를 분리하는 방법은 추후에 설명 


<br>

## 지름길을 택하기 쉬워진다. 
계층형 아키텍처는 결국 같은 계층의 컴포넌트나, 아래 계층의 컴포넌트만 접근 가능하다. 
- 상위 계층의 컴포넌트가 필요하다면? > 간단하게 아래로 내려서 동계층으로 만들면 된다. 

딱 한번 이렇게 하는것은 괜찮으나 일정 등에 의해 지름길을 타기 시작하면 아래처럼 비대해진다. 

<img src="https://user-images.githubusercontent.com/20153890/152680896-1d77e1c3-4017-4d2a-8098-2882d3ec82c4.png" width=300>

> 영속성 계층에서는 모든 것에 접근 가능하기에 점점 비대해진다. 

영속성 계층은 컴포넌트를 아래 계층으로 내릴수록 비대해진다. 헬퍼/유틸등이 가장 큰 후보다

<br>

## 테스트하기 어려워진다. 
계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너 뛰는 것이다. 

**엔티티의 필드를 단 하나만 조작하는 간단한 경우 웹 계층에서 바로 영속성 계층에 접근한다.**

<img src="https://user-images.githubusercontent.com/20153890/152681049-23359de4-0391-40bb-af88-8cbfcb378495.png" width=300>

> 도메인 계층을 건너뛰는 것은 도메인 로직을 코드 여기저기에 흩어지게 만든다. 

계속 이렇게 하다보면 문제가 생기는데.. 
- 추후 비슷한 상황에서도 웹 계층에다 도메인 로직을 구현하게 된다. 핵심 도메인 로직이 웹 계층에 존재하게 될 수 있다.
- 웹 계층 테스트에서 도메인 계층뿐만 아니라, 영속성 계층까지 mocking 해야한다. 
  - 결국 unit test 복잡도가 올라가고 > 테스트 설정이 복잡해지며 > 테스트를 하지 않는 방향으로 가는 첫 걸음이다. 

어느 순간에는 tc를 작성하는 것 보다, 종속성을 이해하고 mock을 만드는데 더 많은 시간이 걸리게 된다. 

<br>

## 유스케이스를 숨긴다.

- 새로운 기능을 추가할 때 간단하면 웹 계층에 바로 추가할 수 있다. 
- 계층을 내려서 도메인/영속성 계층 모두에서 접근할 수 있도록 한다. 

위 처럼 하다보면.. 결국 새로운 기능을 추가할 적당한 위치를 찾는 일은 어려워진다... 

심지어 더 심각한 문제가 생길 수 있는데, 계층형 아키텍처는 `도메인 서비스의 너비` 에 관한 규칙을 강제하지 않기에 
- 아래 그림처럼 여러개의 유스케이스를 담당하는 `아주 넓은 서비스가` 만들어지기도 한다. 

<img src="https://user-images.githubusercontent.com/20153890/152681173-ca3318eb-636e-42b5-a792-5f9d3f173e82.png" width=300>

- 넓은 서비스는 영속성 계층에 많은 의존성을 갖게된다. 
- 많은 웹 계층이 동일 서비스에 의존하게 된다.

결국 서비스를 테스트하기도 어려워지고 작업해야 할 유스케이스를 책임지는 서비스를 찾기도 어려워진다. 

**결론은 분리해라**
- 좁은 도메인 서비스가 유스케이스 하나만 담당하게 하자 
- UserService -> RegisterUserService 

(개인적으로는 적은 인원의 프로젝트라면 일단 전자를 유지하는듯 / 이후 register가 추상화를 가져가야 한다거나, 복잡해지는 경우가 발생하면 분리)

<br>

## 동시작업이 어려워진다. 
인원이 많더라도 동시작업하기 힘들다. 

계층형이다보니.. 3명이 각 계층을 개발한다. 
- 도메인 계층 
- 웹 계층
- 영속성 계층

엇 이게 맞나 ? 

계층형에서는 이렇게 작업할 수 없다. 모든것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야한다. 
(이후 도메인, 마지막으로 웹 계층) 

인터페이스 먼저 정의하고 작업하면 될 수 있지만, 데이터베이스 주도 설계를 하지 않는 경우에만 가능하다. 
- DB 주도 설계는 영속성 로직이 도메인 로직과 너무 뒤섞여서 각 측면으로 개별적 작업이 불가하다. 

또, `넓은 서비스`가 있으면 서로 다른 기능을 동시에 작업하기 어렵다. (conflict) 




 



